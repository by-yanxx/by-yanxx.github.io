---
title: 「JVM」垃圾回收01——概述
date: 2023-02-27
tags: jvm
categories: JavaSE
toc: true
hide: false
---

{% note blue 'fas fa-bullhorn' %}
内容包含：
1. 判断一个对象是否可回收？
2. 对象有哪些引用类型？
{% endnote %}

---

## 判断一个对象是否可以被回收

>什么是垃圾？
>
>垃圾是指运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。

### 引用计数算法

给对象添加一个引用计数器，对象增加一个引用，计数器加 1，引用失效时计数器减  1。

引用计数器为 0 的对象可以被回收。

`弊端`：两对象互相引用时，会发生循环，导致它们无法被回收。因此，JVM 不使用该方法。

### 可达性分析算法

从 GC Roots 开始进行搜索，能够到达的对象就都是存活的，不可达的对象可被回收。

![](../pictures/Pasted%20image%2020230227233328.png)

GC Roots 包括：
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

### 方法区的回收

方法区主要是对常量池的回收和对类的卸载。

### finalize()

类似 C++ 的析构函数，用来关闭外部资源。

但该方法运行代价高，不确定性大，无法保证各个对象的调用顺序，而且有 try-finally 等更好的选择，所以该方法不建议使用。

## 对象的引用类型

>无论是用什么方法，判断对象是否可以被回收都与引用类型相关。
>
>主要有四种：强引用、软引用、弱引用、虚引用。

### 强引用

被强引用关联的对象不会被回收。

方式：使用 new 来创建强引用。

```java
Object obj = new Object();
```

### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

方式：使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引用关联
```

### 弱引用

被引用关联的对象一定会被回收，即，它只能存活到下一次垃圾回收发生之前。

方式：使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### 虚引用

也称 “幽灵引用”、“幻影引用”，一个对象是否有虚引用，完全不会对其生存时间构成影响，无法通过虚引用获取一个对象。

一个对象设置虚引用的唯一目的就是在这个对象被回收时收到一个通知。

方式：使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 垃圾回收算法

### 标记 - 清除

![](../pictures/Pasted%20image%2020230228000636.png)

存活的标记，没被标记的被清理掉。

`不足`：标记和清理过程效率不高，会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 标记 - 整理

![](../pictures/Pasted%20image%2020230228001129.png)

让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 复制

![](../pictures/Pasted%20image%2020230228001224.png)

将内存划分为大小相等的两块，每次只是用其中一块，当这块内存用完了，就将仍存活的对象复制到另一块上面，最后清理使用过的内存空间。

`不足`：只使用了内存的一半。

目前商业虚拟机都采用该方法来回收新生代，但与之不同的是，新生代被划分为 8:1:1 的三块（一块 Eden 区，两块 Survivor 区，具体如何使用的详见 “堆内存之对象分配过程”）。

### 分代收集

根据对象存活周期将内存划分为若干块，不同块采用不同的回收算法。

一般将堆分为新生代和老年代：
- 新生代：使用 “复制” 算法
- 老年代：“标记 - 清除”，或 “标记 - 整理” 算法

## 垃圾收集器



