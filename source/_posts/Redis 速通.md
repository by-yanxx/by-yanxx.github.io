---
title: Redis 速通
date: 2023-04-02
tags: [Redis, 数据库]
categories: Redis
top: 100
---



# Redis

## Redis 简介

Redis 是一种`基于内存`的开源数据库，读写操作都是在内存中完成，所以读写速度非常快，常用于`缓存`、`消息队列`、`分布式锁`等场景。

提供多种数据类型：`String（字符串）`、`Hash（哈希）`、`List（列表）`、`Set（集合）`、`ZSet（有序集合）`、`Bitmaps（位图）`、`HyperLogLog（基数统计）`、`GEO（地理信息）`、`Stream（流）`。

对数据类型的操作都由==单线程完成，是原子性的，无并发问题==。

支持`事务`、`持久化`、`Lua 脚本`、`多种集群方案（主从一致、哨兵、切片机集群）`、`发布/订阅模式`、`内存淘汰机制`、`过期删除机制`等。



## Redis 和 Memcached 区别

`共同点`：

- 都是基于内存的数据库，都被用来当缓存
- 都有过期策略
- 性能都很高

`区别`：

- Redis 支持的数据类型更丰富；Memcached 只支持 \<key-value\> 数据类型
- Redis 有持久化功能，可将内存中的数据保存在磁盘上；Memcached 没有持久化功能，重启电脑，数据全无
- Redis 原生支持集群模式；Memcached 无集群模式
- Redis 支持发布/订阅模式、Lua 脚本、事务等功能；Memcached 则不支持



## 为什么要用 Redis

为什么要用 Redis 作为 MySQL 的缓存？

因为 Redis 的「高性能」与「高并发」两特性。

- `高性能`：对数据库内存的访问速度没有对缓存的访问快，操作 Redis 就是直接操作内存
    - `不足`：数据库中数据发生变化，需要同步修改 Redis，发生双写一致性问题
- `高并发`：处理速度远大于 MySQL，能承受更大的请求压力，某些场景下可以将数据库中的部分数据存放在 Redis 里



# 常见面试题速览

## Redis 数据类型

### 有哪些数据类型、使用场景？

常见的有五种数据类型，及其使用场景：

- `String（字符串）`：缓存对象、常规计数、分布式锁、共享 session 等信息

- `Hash（哈希）`：缓存对象、购物车

- `List（列表）`：消息队列（存在两个问题：1. 生产者需要自行生成全局唯一 id；2. 不能以消费组的形式消费数据）

    - > 如何保证消息有序？：List 本身就是先入先出的顺序。
        >
        > 额外开销如何处理？：List 作为消息队列时，生产者不会通知消费者数据的写入，消费者需要不断调用读取方法，尝试消费消息队列里的消息，如果消息队列里没有内容，则消费者空转，带来性能消耗。解决：阻塞式读取，客户端没有读到队列数据时自动阻塞，有新数据存入消息队列时，消费者才开始读取新数据。
        >
        > 重复消息如何处理？：每个消息有唯一全局 id，消费者比对读取的消息 id 和已处理的消息的 id 来判断消息是否已处理。
        >
        > 

- `Set（集合）`：聚合计算（并集、交集、差集），如：点赞、关注、抽奖等

- `ZSet（有序集合）`：排序场景，如：排行榜、电话和姓名排序等

后来，又支持四种数据类型：

- `BitMap（位图）`：二值状态统计场景，如：签到、判断用户的登录状态
- `HyperLogLog（基数统计）`：海量数据的基数统计，如：网站 UV 统计
- `GEO（地理信息）`：存储地理位置信息，如：滴滴打车
- `Stream（流）`：消息队列（解决了 List 的两个问题：1. 可以自动生成全局唯一 id；2. 支持以消费组的形式消费数据）



### 五种常见的数据类型是如何实现的？

<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402151735558.png" alt="image-20230402151735558" style="zoom:40%;" />

#### String

- `数据结构`：「SDS（简单动态字符串）」

- SDS 有如下特点：

    - 不仅可以保存文本数据，也可以保存==二进制数据==，也就是说可以保存图片、视频、音频等信息

    - 获取字符串长度的时间复杂度是 ==O(1)==

    - ==API 安全==，拼接字符串不会溢出，因为拼接之前会去检查空间是否足够，不足时会扩容



#### List

- `数据结构`：Redis3.0 时用的「双向链表」或「压缩列表」，最新版本用的「quicklist」
- 使用：
    - 如果元素个数小于 512 个（默认值），每个元素小于 64 字节（默认值），Redis 使用「压缩列表」作为 List 的数据结构
    - 否则使用「双向链表」
    - Redis3.2 之后一律使用「quicklist」



#### Hash

- `数据结构`：Redis3.0 时用的「压缩列表」或「哈希表」，最新版本用的「listpack」或「哈希表」
- 使用：和 List 很像
    - 元素个数小于 512 个（默认值），所有值小于 64 字节（默认值），使用「压缩列表」
    - 否则使用「哈希表」
    - 最新版本中实用「listpack」代替「压缩列表」



#### Set

- `数据结构`：「哈希表」或「整数集合」
- 使用：
    - 元素均为整数，元素个数小于 512 个（默认值），使用「整数集合」
    - 否则使用「哈希表」



#### ZSet

- `数据结构`：Redis3.0 时用的「压缩列表」或「跳表」，最新版本用的「listpack」或「跳表」
- 使用：
    - 有序集合的元素个数小于 128 个，每个元素值小于 64 字节，使用「压缩列表」
    - 否则使用「跳表」
    - 最新版本中使用「listpack」代替「压缩列表」



## Redis 数据结构





## Redis 线程模型

### Redis 的单线程

Redis 的单线程指的是==「接收客户端请求 ---> 解析请求 ---> 处理请求 ---> 响应请求」这一过程是单线程的==。

但 Redis 程序并不是单线程的，Redis 启动之后也会开启三个后台线程：

- `BIO_CLOSE_FILE`：关闭文件
- `BIO_AOF_FSYNC`：AOF 刷盘
- `BIO_LAZY_FREE`：异步释放内存

当客户端发出「关闭文件、AOF 刷盘或释放内存」的请求时，如果将其放在主线程里执行，会因为这三个任务都比较耗时导致阻塞，所以将这三个任务扔到任务队列中，由 BIO 不断轮询处理队列中的任务。



### Redis 为什么这么快？

- `内存中执行 + 高效的数据结构`：Redis 的瓶颈在于「网络带宽」或「内存大小」，而非 CPU
- `单线程`：没有使用多线程，也就避免了「线程切换开销」和「死锁问题」
- `I/O 多路复用机制`：一个线程处理多个 IO 流，即「select/epoll 机制」



### 为什么引入多线程？

早期 Redis 的网络 I/O 和执行命令都是单线程的，因为制约 Redis 的不在于 CPU，而在于网络 I/O 与计算机内存大小。

随着网络硬件的进步，内存的扩大，Redis 的性能瓶颈主要在「网络 I/O」的处理上，所以在 Redis6.0 之后，==使用多线程来处理网络 I/O，但执行命令依旧是用单线程==。

默认情况下，I/O 多线程只针对发送响应数据（write client socket），并不会处理读请求（read client socket）。

综上，开启 Redis 后，默认情况下，在主线程 `Redis-server` 之外，会额外创建 6 个线程：

- `BIO_CLOSE_FILE`、`BIO_AOF_FSYNC`、`BIO_LAZY_FREE`：三个后台线程
- `IO_THD_1`、`IO_THD_2`、`IO_THD_3`：三个 I/O 线程（io-threads 默认为 4，开启 3 个线程比较合适），负责分担网络 I/O 压力



## Redis 持久化

### Redis 如何保证数据不丢失？

Redis 的读写操作都在内存中进行，如果重启 Redis，内存释放，数据便会丢失。所以，Redis 通过「持久化机制」将数据写入磁盘。

三种持久化方式：

- `AOF 日志`：全称 Append Only File（追加日志文件），每执行一个「写操作」，也会把「执行命令」记录到一个文件中
- `RDB 快照`：全称 Redis Database Backup file（Redis 数据备份文件），将某一时刻的内存数据，以二进制的方式写入磁盘
- `混合持久化方式`：AOF + RDB



### AOF 日志如何实现的？

<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402160327538.png" alt="image-20230402160327538" style="zoom:40%;" />

<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402160337007.png" alt="image-20230402160337007" style="zoom:50%;" />





#### 为什么要先执行命令，后将命令记录到日志？

- 好处：
    - `避免额外的检查开销`：如果不对执行命令进行检查就先写入日志中，一旦命令有误，那么在恢复时就会发生错误
    - `不会阻塞当前命令`：记录命令到日志中这个操作也是在主线程中进行的，和当前命令是同步关系，所以先记录日志后执行命令会阻塞当前命令
- 坏处：
    - `有数据丢失风险`：执行完写命令后，在记录日志之前发生宕机，数据丢失
    - `可能阻塞其他命令`：将当前命令记录到日志中这一操作，虽然不会阻塞当前命令，但可能阻塞后续的命令



#### AOF 写回策略有几种？

> 从执行命令到写入磁盘的顺序：
>
> 执行写命令 ---> 命令追加到 server.aof_buf 缓冲区*（还会写到 AOF 重写缓冲区，这个后面会讲）* ---> I/O 系统调用 write()，将 aof_buf 缓冲区数据写入 AOF ---> 数据拷贝到内核缓冲区 page cache，等待写入磁盘 ---> （等待） ---> 真正地写入硬盘

何时将内核缓冲区的数据真正地写入硬盘，由内核决定，这个决定策略（即写回策略）有三种：

- `Always`：每次写操作执行完命令后，同步将 AOF 日志数据写回硬盘
- `Everysec`：先将数据写入 AOF 文件的内核缓冲区 page cache，然后每隔一秒将缓冲区中的数据写回硬盘
- `No`：不由  Redis 控制写回硬盘的时机，由操作系统控制写回时机，即，先将数据写入 AOF 文件的内核缓冲区，再由操作系统决定何时写回硬盘



<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402162615442.png" alt="image-20230402162615442" style="zoom:40%;" />



#### AOF 日志过大，会触发什么机制？

不断地将写操作的执行命令追加到文件后面，日志文件不断变大，Redis 重启时恢复数据的时间也随之变长。为此，Redis 通过==「AOF 重写机制」==来解决这一问题，当 AOF 文件大小超过设定的阈值时，启动 AOF 重写机制，来压缩 AOF 文件。

> 简单来说，就是扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志。

比如：先执行了 `set name yby` 命令，后执行了 `set name yanxx` 命令，那么 AOF 日志中会有两条记录，分别对应这两个操作。重写 AOF 时，对于键值对 `<name-yanxx>` 来说，前一个键值对 `<name-yby>` 就是过期的，是可以删掉的，所以重写后内存中只保留 `<name-yanxx>` 这一个键值对，最后将其转为一条命令记录到重写日志中，实现压缩。*（这只是一条数据，其他多条数据也是依次执行这个过程。）*



<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402163805682.png" alt="image-20230402163805682" style="zoom:50%;" />



重写之后，覆盖原来的 AOF 日志文件即可。



#### 重写 AOF 日志过程？

由后台==子进程== `bgrewriteaof` 完成。

好处：

- `避免阻塞`：重写期间，主进程继续处理命令请求，由子进程完成可以避免阻塞
- `性能考虑`：由子进程完成，而不是线程，是出于性能的考虑。多线程之间共享内存，修改共享内存数据时需要加锁保证线程安全，导致性能降低。父进程和用来重写的子进程也会共享内存数据，但是以只读的方式共享，父进程或子进程对共享内存数据做出改动时，会发生==「写时复制」==，无需加锁即可保证数据安全

重写过程：触发 AOF 重写机制，主进程创建用于重写的子进程，子进程拿到主进程数据的副本，对内存数据只读，逐一将内存数据的键值对转为一条命令，记录到新的 AOF 日志文件。

> 在重写的过程中，主进程依然可以正常处理命令，那如果在重写 AOF 日志过程中，主进程修改了一个已存在的键值对，那么此时发生「写时复制」，导致这条数据在子进程和主进程中不一致，如何处理？
>
> 答：AOF 重写缓冲区。

为解决数据不一致问题，Redis 设置了==「AOF 重写缓冲区」==，在创建 `bgrewriteaof` 子进程之后开始使用。



<img src="/Users/by_yan/Documents/Typora Notes/专业向/Redis/.assets/image-20230402171812907.png" alt="image-20230402171812907" style="zoom:40%;" />



即，==在重写 AOF 期间==，主进程执行命令之后，会将命令写入「AOF 缓冲区」和「AOF 重写缓冲区」。子进程完成 AOF 重写工作后，向主进程发送一条信号，主进程收到信号后，调用信号处理函数，该函数主要完成两件事：

1. 将 AOF 重写缓冲区中的所有内容追加到新的 AOF 文件中，使新旧两个 AOF 日志文件所保存的数据库状态一致
2. 将新的 AOF 文件改名，覆盖现有 AOF 文件

发现：Redis7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁
盘==两次==。

> 





















## Redis 集群





## Redis 过期删除与内存淘汰





## Redis 缓存设计





## Redis 实战











































