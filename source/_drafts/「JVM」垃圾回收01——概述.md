---
title: 「JVM」垃圾回收01——概述
date: 2023-02-27
tags: jvm
categories: javase
toc: true
hide: false
---

{% note blue 'fas fa-bullhorn' %}
内容包含：
1. 判断一个对象是否可回收？
2. 对象有哪些引用类型？
3. 有哪些垃圾回收算法？
4. 七种垃圾收集器？
5. 内存分配与回收的策略？
{% endnote %}

---

## 判断一个对象是否可以被回收

>什么是垃圾：垃圾是指运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。
>  
>什么是 GC：Garbage Collector，垃圾收集器。

### 引用计数算法

给对象添加一个引用计数器，对象增加一个引用，计数器加 1，引用失效时计数器减  1。

引用计数器为 0 的对象可以被回收。

`弊端`：两对象互相引用时，会发生循环，导致它们无法被回收。因此，JVM 不使用该方法。

### 可达性分析算法

从 GC Roots 开始进行搜索，能够到达的对象就都是存活的，不可达的对象可被回收。

![](../pictures/Pasted%20image%2020230227233328.png)

GC Roots 包括：
- 虚拟机栈中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中的常量引用的对象

### 方法区的回收

方法区主要是对常量池的回收和对类的卸载。

### finalize()

类似 C++ 的析构函数，用来关闭外部资源。

但该方法运行代价高，不确定性大，无法保证各个对象的调用顺序，而且有 try-finally 等更好的选择，所以该方法不建议使用。

## 对象的引用类型

>无论是用什么方法，判断对象是否可以被回收都与引用类型相关。
>
>主要有四种：强引用、软引用、弱引用、虚引用。

### 强引用

被强引用关联的对象不会被回收。

方式：使用 new 来创建强引用。

```java
Object obj = new Object();
```

### 软引用

被软引用关联的对象只有在内存不够的情况下才会被回收。

方式：使用 SoftReference 类来创建软引用。

```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引用关联
```

### 弱引用

被引用关联的对象一定会被回收，即，它只能存活到下一次垃圾回收发生之前。

方式：使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```

### 虚引用

也称 “幽灵引用”、“幻影引用”，一个对象是否有虚引用，完全不会对其生存时间构成影响，无法通过虚引用获取一个对象。

一个对象设置虚引用的唯一目的就是在这个对象被回收时收到一个通知。

方式：使用 PhantomReference 来实现虚引用。

```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
obj = null;
```

## 垃圾回收算法

### 标记 - 清除

![](../pictures/Pasted%20image%2020230228000636.png)

存活的标记，没被标记的被清理掉。

`不足`：标记和清理过程效率不高，会产生大量不连续的内存碎片，导致无法给大对象分配内存。

### 标记 - 整理

![](../pictures/Pasted%20image%2020230228001129.png)

让所有的对象都向一端移动，然后直接清理掉端边界以外的内存。

### 复制

![](../pictures/Pasted%20image%2020230228001224.png)

将内存划分为大小相等的两块，每次只是用其中一块，当这块内存用完了，就将仍存活的对象复制到另一块上面，最后清理使用过的内存空间。

`不足`：只使用了内存的一半。

目前商业虚拟机都采用该方法来回收新生代，但与之不同的是，新生代被划分为 8:1:1 的三块（一块 Eden 区，两块 Survivor 区，具体如何使用的详见 “堆内存之对象分配过程”）。

### 分代收集

根据对象存活周期将内存划分为若干块，不同块采用不同的回收算法。

一般将堆分为新生代和老年代：
- 新生代：使用 “复制” 算法
- 老年代：“标记 - 清除”，或 “标记 - 整理” 算法

## 垃圾收集器

>下面是 HotSpot 虚拟机中的七个垃圾收集器，连线表示配合使用。
>
>单线程与多线程：这里单线程指的是垃圾收集器只用一个线程进行收集。
> 
>串行与并行：这里的串行指的是垃圾收集器与用户程序交替进行，需要停顿用户的程序；并行则指的是垃圾收集器与用户程序同时执行。
>
>除了 CMS 和 G1 外，其他垃圾收集器都是串行的。

![](../pictures/Pasted%20image%2020230228100713.png)

### Serial 收集器

![](../pictures/Pasted%20image%2020230228101317.png)

Serial 表示 “串行”，该收集器是单线程的，是 Client 模式下的默认新生代收集器。

`优点`：简单高效，对单个 CPU 来说，拥有最高效的垃圾收集效率。

### ParNew 收集器

![](../pictures/Pasted%20image%2020230228101810.png)

它是 Serial 收集器的多线程的版本，是 Server 模式下的首选新生代收集器，默认的线程数量与 CPU 数量相同，可以用 `-XX:ParallelGCThreads` 参数来设置线程数。

抛开性能原因，主要是因为只有它能与 CMS 收集器配合工作。

### Parallel Scavenge 收集器

它也是多线程收集器，其关注的不是垃圾收集时用户程序的停顿时间，而是吞吐量，所以它也叫 “吞吐量优先” 收集器。

>吞吐量：在这里指的是 CPU 用于运行用户代码的时间和总时间的比值。

垃圾收集时停顿的时间越短，就越适合那些与用户交互的程序（良好的响应速度能提升用户体验）。

高吞吐量可以高效地利用 CPU 时间，尽快完成程序任务，更适用于在后台运算而不需要太多交互的任务。

垃圾收集时停顿时间的缩短是以牺牲吞吐量和新生代空间来换区的，新生代空间变小，垃圾回收变得频繁，吞吐量下降。

### Serial Old 收集器

![](../pictures/Pasted%20image%2020230228103454.png)

Serial 收集器的老年代版本，给 Client 模式下的虚拟机使用，在 Server 模式下，有如下用途：
- 在 JDK1.5 及其之前版本，它与 Parallel Scavenge 收集器配合使用
- 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用

>Concurrent Mode Failure：是指并发周期还没执行完，用户线程就来请求比预留空间更大的空间了，即后台线程的收集没有赶上应用线程的分配速度。

### Parallel Old 收集器

![](../pictures/Pasted%20image%2020230228103820.png)

是 Parallel Scavenge 收集器的老年代版本。

在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。

### CMS 收集器

![](../pictures/Pasted%20image%2020230228103923.png)

CMS(Concurrent Mark Sweep)，Mark Sweep 指的是 “标记 - 清除” 算法。

`四个流程`：
- 初始标记：仅标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿
- 并发标记：进行 GC Roots Tracing 的过程，耗时最长，不需要停顿
- 重新标记：用于修正并发标记期间因程序运行导致标记变动的那一部分的对象标记记录，需要停顿
- 并发清除：无需停顿

`不足`：
- 吞吐量低：拥有较低的停顿时间，却牺牲了吞吐量，导致 CPU 利用率不高
- 无法处理浮动垃圾：可能出现 Concurrent Mode Failure。浮动垃圾是指在并发清除阶段因程序的继续运行而产生的垃圾，这些垃圾只能在下一次 GC 时才能被回收掉。因浮动垃圾的存在，所以需要预留出一部分内存来保证足够存放浮动垃圾，否则会 Concurrent Mode Failure，也是因此，CMS 不能像其他垃圾收集器那样等到老年代快满的时候再回收。当发生 Concurrent Mode Failure 时，虚拟机临时使用 Serial Old 来代替 CMS
- 空间碎片：“标记 - 清除” 算法会导致空间碎片的产生，进而导致老年代空间剩余，但没有足够大的连续空间去存储对象，不得不提前触发一次 Full GC

### G1 收集器

G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。它可以同时对新生代和老年代进行垃圾回收。

![](../pictures/Pasted%20image%2020230228105146.png)

G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。

![](../pictures/Pasted%20image%2020230228105207.png)

通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。

`工作方式`：通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。

每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

![](../pictures/Pasted%20image%2020230228105516.png)

如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：
- 初始标记
- 并发标记
- 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行
- 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率

`特点`：
- 空间整合：整体来看是基于 “标记 - 整理” 算法实现的收集器，从局部(两个 Region 之间)上来看是基于 “复制” 算法实现的，这意味着运行期间不会产生内存空间碎片
- 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒

### 小结

了解即可：
![](../pictures/Pasted%20image%2020230228150621.png)

*“标记 - 压缩” 也就是 “标记 - 整理”*

## 内存分配与回收策略

### Minor GC、Major GC、Full GC

>JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）:
- 部分收集：不是完整收集整个 Java 堆的垃圾收集，可以继续分为：
	- 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
	- 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集
		- 目前，只有 CMS GC 会有单独收集老年代的行为
		- 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
	- 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集
		- 目前只有 G1 GC 会有这种行为
- 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾

### 内存分配策略

1. **对象优先在新生代 Eden 区分配**
	不够用时触发 Minor GC。
2. **大对象直接进入老年代**
	大对象，指的是需要连续内存空间的对象，比如超长的数组或字符串。
3. **长期存活的对象进入老年代**
	为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
4. **动态对象年龄判定**
	如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代
5. **空间分配担保**
	在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；
	否则，虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许担保，则继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则尝试进行一次 Minor GC，如果小于或者不允许担保，则进行一次 Full GC

### Full GC 的触发条件

对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:

1. 调用 System.gc()
	只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
2. 老年代空间不足
	老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。避免策略：
	- 尽量不要创建过大的对象和数组
	- 通过 `-Xmn` 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代
	- 通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间
3. 空间分配担保失败
	使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。
4. JDK1.7 及以前的永久代空间不足
	当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。避免策略：
	- 增大永久代空间
	- 转为使用 CMS GC
5. Concurrent Mode Failure
	执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。